<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulacja Rzutu Ukośnego</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Zmienione źródło na unpkg dla lepszej dostępności i nowszej wersji -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { touch-action: none; }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white shadow-sm p-4 z-10">
        <div class="max-w-6xl mx-auto flex items-center gap-2">
            <i data-lucide="activity" class="text-blue-600"></i>
            <h1 class="text-xl font-bold text-slate-800">Symulator Rzutu Ukośnego</h1>
        </div>
    </header>

    <!-- Main Layout -->
    <main class="flex-grow flex flex-col lg:flex-row max-w-6xl mx-auto w-full p-4 gap-6">
        
        <!-- Controls Panel -->
        <aside class="w-full lg:w-1/3 space-y-4">
            <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                <h2 class="font-semibold text-lg mb-4 flex items-center gap-2">
                    <i data-lucide="sliders" class="w-5 h-5"></i> Parametry
                </h2>

                <!-- Velocity Control -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Prędkość początkowa ($v_0$)</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="velocity" min="1" max="100" value="25" step="1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-16 text-right font-mono text-sm"><span id="val-velocity">25</span> m/s</span>
                    </div>
                </div>

                <!-- Angle Control -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Kąt rzutu ($\alpha$)</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="angle" min="0" max="90" value="45" step="1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-16 text-right font-mono text-sm"><span id="val-angle">45</span>°</span>
                    </div>
                </div>

                <!-- Height Control -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Wysokość początkowa ($h_0$)</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="height" min="0" max="50" value="0" step="1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-16 text-right font-mono text-sm"><span id="val-height">0</span> m</span>
                    </div>
                </div>

                <!-- Gravity Control -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Przyspieszenie ($g$)</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="gravity" min="1.6" max="20" value="9.81" step="0.1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-16 text-right font-mono text-sm"><span id="val-gravity">9.81</span> m/s²</span>
                    </div>
                </div>

                <button id="anim-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors flex justify-center items-center gap-2">
                    <i data-lucide="play" class="w-4 h-4"></i> Uruchom animację
                </button>
            </div>

            <!-- Results Panel -->
            <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                <h2 class="font-semibold text-lg mb-4 flex items-center gap-2">
                    <i data-lucide="calculator" class="w-5 h-5"></i> Wyniki
                </h2>
                <div class="grid grid-cols-2 gap-4">
                    <div class="p-3 bg-slate-50 rounded border border-slate-100">
                        <div class="text-xs text-slate-500 uppercase tracking-wide">Zasięg ($Z$)</div>
                        <div class="text-xl font-bold text-slate-800" id="res-range">-</div>
                    </div>
                    <div class="p-3 bg-slate-50 rounded border border-slate-100">
                        <div class="text-xs text-slate-500 uppercase tracking-wide">Max Wysokość ($H_{max}$)</div>
                        <div class="text-xl font-bold text-slate-800" id="res-hmax">-</div>
                    </div>
                    <div class="p-3 bg-slate-50 rounded border border-slate-100 col-span-2">
                        <div class="text-xs text-slate-500 uppercase tracking-wide">Całkowity czas lotu ($t_c$)</div>
                        <div class="text-xl font-bold text-slate-800" id="res-time">-</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Visualization Panel -->
        <section class="flex-grow bg-white rounded-lg shadow-sm border border-slate-200 relative overflow-hidden flex flex-col">
            <div class="absolute top-4 right-4 bg-white/90 backdrop-blur px-3 py-1 rounded border border-slate-200 text-xs font-mono text-slate-500 z-10 pointer-events-none">
                Skala: <span id="scale-indicator">1.0</span> px/m
            </div>
            <div class="flex-grow relative w-full h-[400px] lg:h-auto" id="canvas-container">
                <canvas id="simCanvas" class="block w-full h-full cursor-crosshair"></canvas>
            </div>
        </section>
    </main>

    <script>
        // --- Inicjalizacja Ikon (z obsługą błędów) ---
        try {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                console.warn("Lucide library not loaded instantly. Waiting for window load.");
                window.addEventListener('load', () => {
                     if (typeof lucide !== 'undefined') lucide.createIcons();
                });
            }
        } catch (e) {
            console.error("Failed to load icons:", e);
        }

        // --- Konfiguracja i Stan ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        const inputs = {
            v0: document.getElementById('velocity'),
            angle: document.getElementById('angle'),
            h0: document.getElementById('height'),
            g: document.getElementById('gravity')
        };

        const labels = {
            v0: document.getElementById('val-velocity'),
            angle: document.getElementById('val-angle'),
            h0: document.getElementById('val-height'),
            g: document.getElementById('val-gravity')
        };

        const results = {
            range: document.getElementById('res-range'),
            hmax: document.getElementById('res-hmax'),
            time: document.getElementById('res-time'),
            scale: document.getElementById('scale-indicator')
        };

        let state = {
            v0: 25,
            angle: 45,
            h0: 0,
            g: 9.81,
            tTotal: 0,
            range: 0,
            hMax: 0,
            animating: false,
            animTime: 0
        };

        let view = {
            width: 0,
            height: 0,
            scale: 10, // px per meter
            offsetX: 50,
            offsetY: 50 // from bottom
        };

        let animationId = null;

        // --- Logika Fizyczna ---

        function calculatePhysics() {
            const rad = state.angle * (Math.PI / 180);
            const v0x = state.v0 * Math.cos(rad);
            const v0y = state.v0 * Math.sin(rad);

            // Obliczanie czasu całkowitego (rozwiązanie równania kwadratowego dla y=0)
            // y(t) = h0 + v0y*t - 0.5*g*t^2 = 0
            // Delta = b^2 - 4ac => v0y^2 - 4*(-0.5g)*h0 = v0y^2 + 2*g*h0
            
            const delta = (v0y * v0y) + (2 * state.g * state.h0);
            const t1 = (-v0y - Math.sqrt(delta)) / (-state.g);
            const t2 = (-v0y + Math.sqrt(delta)) / (-state.g);
            
            state.tTotal = Math.max(t1, t2); // Wybieramy dodatni czas

            // Zasięg
            state.range = v0x * state.tTotal;

            // Max wysokość
            // t_max_h = v0y / g
            const tMaxH = v0y / state.g;
            state.hMax = state.h0 + (v0y * tMaxH) - (0.5 * state.g * tMaxH * tMaxH);
            
            // Jeśli rzut w dół z wysokości, max wysokość to h0
            if (tMaxH < 0) state.hMax = state.h0; 
        }

        function getPositionAtTime(t) {
            const rad = state.angle * (Math.PI / 180);
            const v0x = state.v0 * Math.cos(rad);
            const v0y = state.v0 * Math.sin(rad);

            const x = v0x * t;
            const y = state.h0 + (v0y * t) - (0.5 * state.g * t * t);
            
            return { x, y };
        }

        // --- Renderowanie ---

        function resizeCanvas() {
            view.width = container.clientWidth;
            view.height = container.clientHeight;
            canvas.width = view.width;
            canvas.height = view.height;
            draw();
        }

        function worldToScreen(wx, wy) {
            return {
                x: view.offsetX + (wx * view.scale),
                y: view.height - view.offsetY - (wy * view.scale)
            };
        }

        function drawGrid() {
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            // Siatka pionowa (co 10m lub więcej w zależności od skali)
            const step = view.scale < 2 ? 50 : (view.scale < 5 ? 20 : 10);
            
            ctx.beginPath();
            for (let w = 0; w * view.scale < view.width; w += step) {
                const pos = worldToScreen(w, 0);
                ctx.moveTo(pos.x, 0);
                ctx.lineTo(pos.x, view.height);
                // Etykiety
                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px sans-serif';
                if(w > 0) ctx.fillText(w + 'm', pos.x + 2, view.height - 10);
            }
            
            // Siatka pozioma
            for (let h = 0; h * view.scale < view.height; h += step) {
                const pos = worldToScreen(0, h);
                ctx.moveTo(0, pos.y);
                ctx.lineTo(view.width, pos.y);
                if(h > 0) ctx.fillText(h + 'm', 5, pos.y - 2);
            }
            ctx.stroke();

            // Osie
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Oś X (ziemia)
            const zeroPos = worldToScreen(0, 0);
            ctx.moveTo(0, zeroPos.y);
            ctx.lineTo(view.width, zeroPos.y);
            // Oś Y
            ctx.moveTo(view.offsetX, 0);
            ctx.lineTo(view.offsetX, view.height);
            ctx.stroke();
        }

        function drawTrajectory() {
            ctx.beginPath();
            ctx.strokeStyle = '#3b82f6'; // blue-500
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // Rysujemy ścieżkę z rozdzielczością np. 100 punktów
            const steps = 100;
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * state.tTotal;
                const pos = getPositionAtTime(t);
                const screenPos = worldToScreen(pos.x, pos.y);
                if (i === 0) ctx.moveTo(screenPos.x, screenPos.y);
                else ctx.lineTo(screenPos.x, screenPos.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawProjectile(t) {
            const pos = getPositionAtTime(t);
            const screenPos = worldToScreen(pos.x, pos.y);

            // Cień
            ctx.beginPath();
            ctx.ellipse(screenPos.x, worldToScreen(pos.x, 0).y, 6, 2, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fill();

            // Piłka
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#dc2626'; // red-600
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateScale() {
            // Autoskalowanie: chcemy, aby cały tor lotu mieścił się w widoku z marginesem
            // Max X to range, Max Y to hMax
            const targetWidth = state.range * 1.2; 
            const targetHeight = state.hMax * 1.5; // Większy margines dla góry

            // Obliczamy skalę dla X i Y, wybieramy mniejszą (żeby wszystko się zmieściło)
            const availableWidth = view.width - view.offsetX - 20;
            const availableHeight = view.height - view.offsetY - 20;

            const scaleX = availableWidth / Math.max(10, targetWidth);
            const scaleY = availableHeight / Math.max(10, targetHeight);

            view.scale = Math.min(scaleX, scaleY);
            results.scale.innerText = view.scale.toFixed(2);
        }

        function draw() {
            ctx.clearRect(0, 0, view.width, view.height);
            drawGrid();
            drawTrajectory();
            
            if (state.animating) {
                drawProjectile(state.animTime);
            } else {
                // Rysuj pozycję startową jeśli nie animujemy
                drawProjectile(0);
            }
        }

        // --- Obsługa Zdarzeń ---

        function updateState() {
            state.v0 = parseFloat(inputs.v0.value);
            state.angle = parseFloat(inputs.angle.value);
            state.h0 = parseFloat(inputs.h0.value);
            state.g = parseFloat(inputs.g.value);

            // UI Update
            labels.v0.innerText = state.v0;
            labels.angle.innerText = state.angle;
            labels.h0.innerText = state.h0;
            labels.g.innerText = state.g;

            calculatePhysics();

            // UI Results Update
            results.range.innerText = state.range.toFixed(2) + " m";
            results.hmax.innerText = state.hMax.toFixed(2) + " m";
            results.time.innerText = state.tTotal.toFixed(2) + " s";

            updateScale();
            draw();
        }

        // Event Listeners dla suwaków
        Object.values(inputs).forEach(input => {
            input.addEventListener('input', () => {
                if (state.animating) stopAnimation();
                updateState();
            });
        });

        // Resize observer
        window.addEventListener('resize', resizeCanvas);

        // Animation Loop
        document.getElementById('anim-btn').addEventListener('click', () => {
            if (state.animating) return;
            startAnimation();
        });

        function startAnimation() {
            state.animating = true;
            state.animTime = 0;
            let startTime = performance.now();
            const duration = state.tTotal; // w sekundach

            function loop(currentTime) {
                if (!state.animating) return;

                const dt = (currentTime - startTime) / 1000; // czas od startu w sekundach
                // Przyspieszamy lekko czas dla bardzo długich lotów, ale dla fizyki trzymajmy 1:1 zazwyczaj
                // Tutaj zrobimy prosty real-time
                state.animTime = dt;

                if (state.animTime >= duration) {
                    state.animTime = duration;
                    draw();
                    state.animating = false;
                    return;
                }

                draw();
                animationId = requestAnimationFrame(loop);
            }

            animationId = requestAnimationFrame(loop);
        }

        function stopAnimation() {
            state.animating = false;
            cancelAnimationFrame(animationId);
            draw();
        }

        // Start
        setTimeout(() => {
            resizeCanvas();
            updateState();
        }, 100);

    </script>
</body>
</html>