<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulacja Dyfrakcji Fal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        /* Wyłączenie interpolacji dla efektu "pikseli" przy powiększeniu, co poprawia wydajność */
        canvas { 
            image-rendering: pixelated; 
            touch-action: none;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white shadow-sm p-4 z-10">
        <div class="max-w-6xl mx-auto flex items-center gap-2">
            <i data-lucide="waves" class="text-blue-600"></i>
            <h1 class="text-xl font-bold text-slate-800">Symulator Dyfrakcji i Interferencji</h1>
        </div>
    </header>

    <!-- Main Layout -->
    <main class="flex-grow flex flex-col lg:flex-row max-w-6xl mx-auto w-full p-4 gap-6">
        
        <!-- Controls Panel -->
        <aside class="w-full lg:w-1/3 space-y-4">
            <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                <h2 class="font-semibold text-lg mb-4 flex items-center gap-2">
                    <i data-lucide="settings-2" class="w-5 h-5"></i> Ustawienia
                </h2>

                <!-- Obstacle Type -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-2">Rodzaj przeszkody</label>
                    <div class="flex gap-2">
                        <button id="btn-single" class="flex-1 py-2 px-3 text-sm rounded bg-blue-100 text-blue-700 border border-blue-200 hover:bg-blue-200 font-medium transition-colors active-mode">
                            Pojedyncza szczelina
                        </button>
                        <button id="btn-double" class="flex-1 py-2 px-3 text-sm rounded bg-slate-100 text-slate-600 border border-slate-200 hover:bg-slate-200 transition-colors">
                            Podwójna szczelina
                        </button>
                    </div>
                </div>

                <!-- Slit Width -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Szerokość szczeliny</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="slit-size" min="2" max="20" value="6" step="1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-12 text-right font-mono text-sm" id="val-slit">6</span>
                    </div>
                    <p class="text-xs text-slate-400 mt-1">Im węższa szczelina, tym silniejsza dyfrakcja.</p>
                </div>

                <!-- Frequency -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-slate-600 mb-1">Częstotliwość źródła</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="frequency" min="1" max="20" value="10" step="1" 
                               class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        <span class="w-12 text-right font-mono text-sm" id="val-freq">10</span>
                    </div>
                </div>

                <div class="flex gap-2">
                    <button id="btn-pause" class="flex-1 bg-slate-800 hover:bg-slate-700 text-white font-medium py-2 px-4 rounded-md transition-colors flex justify-center items-center gap-2">
                        <i data-lucide="pause" class="w-4 h-4"></i> <span id="txt-pause">Pauza</span>
                    </button>
                    <button id="btn-reset" class="flex-1 bg-white border border-slate-300 hover:bg-slate-50 text-slate-700 font-medium py-2 px-4 rounded-md transition-colors flex justify-center items-center gap-2">
                        <i data-lucide="rotate-ccw" class="w-4 h-4"></i> Reset
                    </button>
                </div>
            </div>

            <!-- Legend/Info -->
            <div class="bg-blue-50 p-4 rounded-lg border border-blue-100 text-sm text-blue-800">
                <h3 class="font-semibold mb-2 flex items-center gap-2">
                    <i data-lucide="info" class="w-4 h-4"></i> Jak to działa?
                </h3>
                <p>Symulacja rozwiązuje dyskretne równanie falowe. Jaśniejsze kolory oznaczają grzbiety fali, ciemniejsze doliny. Przeszkoda (czarna linia) blokuje fale, zmuszając je do ugięcia na krawędziach.</p>
            </div>
        </aside>

        <!-- Visualization Panel -->
        <section class="flex-grow bg-black rounded-lg shadow-sm border border-slate-200 overflow-hidden flex flex-col justify-center items-center relative aspect-video lg:aspect-auto">
            <!-- Canvas is scaled via CSS to fit, but internal resolution is fixed for physics performance -->
            <canvas id="waveCanvas" width="300" height="200" class="w-full h-full object-contain"></canvas>
            
            <div class="absolute bottom-4 left-4 text-xs text-white/50 font-mono pointer-events-none">
                FPS: <span id="fps-counter">0</span> | Grid: 300x200
            </div>
        </section>
    </main>

    <script>
        // --- Inicjalizacja Ikon ---
        try {
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            } else {
                window.addEventListener('load', () => {
                     if (typeof lucide !== 'undefined') lucide.createIcons();
                });
            }
        } catch (e) { console.error(e); }

        // --- Parametry Symulacji ---
        const WIDTH = 300;
        const HEIGHT = 200;
        const DAMPING = 0.99; // Tłumienie globalne (żeby fale wygasały)
        const WALL_X = 80;    // Pozycja ściany na osi X

        // Tablice stanu symulacji (bufory)
        // buffer1: obecny stan, buffer2: poprzedni stan
        let buffer1 = new Float32Array(WIDTH * HEIGHT);
        let buffer2 = new Float32Array(WIDTH * HEIGHT);
        // Tablica określająca, gdzie są ściany (1 = ściana, 0 = pusto)
        let walls = new Uint8Array(WIDTH * HEIGHT);
        // Bufor obrazu do rysowania
        let imageBuffer = new Uint32Array(WIDTH * HEIGHT);

        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        // ImageData umożliwia bezpośredni dostęp do pikseli (wydajność)
        const imageData = ctx.createImageData(WIDTH, HEIGHT);
        // Widok 32-bitowy na dane pikseli dla szybszego zapisu
        const data32 = new Uint32Array(imageData.data.buffer);

        // Stan aplikacji
        let running = true;
        let time = 0;
        let mode = 'single'; // 'single' | 'double'
        let slitSize = 6;
        let frequency = 0.2; // Przeliczone z suwaka

        // Elementy UI
        const ui = {
            btnSingle: document.getElementById('btn-single'),
            btnDouble: document.getElementById('btn-double'),
            inpSlit: document.getElementById('slit-size'),
            valSlit: document.getElementById('val-slit'),
            inpFreq: document.getElementById('frequency'),
            valFreq: document.getElementById('val-freq'),
            btnPause: document.getElementById('btn-pause'),
            txtPause: document.getElementById('txt-pause'),
            btnReset: document.getElementById('btn-reset'),
            fps: document.getElementById('fps-counter')
        };

        // --- Logika Fizyczna (Wave Equation) ---

        function initWalls() {
            // Czyścimy ściany
            walls.fill(0);

            // Rysujemy pionową ścianę w WALL_X
            for (let y = 0; y < HEIGHT; y++) {
                let isGap = false;
                const cy = HEIGHT / 2;

                if (mode === 'single') {
                    // Pojedyncza szczelina na środku
                    if (y >= cy - slitSize && y <= cy + slitSize) {
                        isGap = true;
                    }
                } else {
                    // Podwójna szczelina (interferencja Younga)
                    const separation = 20; // Odległość między szczelinami
                    if ((y >= cy - separation - slitSize && y <= cy - separation + slitSize) ||
                        (y >= cy + separation - slitSize && y <= cy + separation + slitSize)) {
                        isGap = true;
                    }
                }

                if (!isGap) {
                    walls[y * WIDTH + WALL_X] = 1;
                }
            }
        }

        function updatePhysics() {
            for (let i = 0; i < WIDTH * HEIGHT; i++) {
                // Prosta symulacja: fala płaska generowana z lewej strony
                // Wymuszamy amplitudę na lewym brzegu (x=0, x=1)
                const x = i % WIDTH;
                const y = Math.floor(i / WIDTH);

                if (x === 1) {
                    // Źródło fali płaskiej
                    buffer1[i] = Math.sin(time * frequency) * 255; 
                    continue;
                } 
                
                // Jeśli jesteśmy na brzegu (tłumienie brzegowe - Absorbing Boundary Condition 'light')
                if (x === 0 || x === WIDTH - 1 || y === 0 || y === HEIGHT - 1) {
                    buffer1[i] = 0; 
                    continue;
                }

                // Jeśli tu jest ściana, amplituda = 0
                if (walls[i] === 1) {
                    buffer1[i] = 0;
                    continue;
                }

                // Standardowy algorytm fali 2D
                // wave[x,y] = (u[x-1,y] + u[x+1,y] + u[x,y-1] + u[x,y+1]) / 2 - u_prev[x,y]
                // + tłumienie
                
                const val = (
                    buffer1[i - 1] + 
                    buffer1[i + 1] + 
                    buffer1[i - WIDTH] + 
                    buffer1[i + WIDTH]
                ) / 2 - buffer2[i];

                buffer2[i] = val * DAMPING;
            }

            // Zamiana buforów
            let temp = buffer1;
            buffer1 = buffer2;
            buffer2 = temp;

            time++;
        }

        // --- Renderowanie ---

        function render() {
            for (let i = 0; i < WIDTH * HEIGHT; i++) {
                // Ściany rysujemy na szaro
                if (walls[i] === 1) {
                    data32[i] = 0xFF404040; // AABBGGRR (little endian) -> Szary
                    continue;
                }

                // Mapujemy amplitudę (-255 do 255) na kolor
                // Używamy odcieni niebieskiego.
                // 0 -> Średni niebieski
                // + -> Jasny (biel)
                // - -> Ciemny (granat/czarny)
                
                let val = buffer1[i];
                
                // Clamp
                if (val > 255) val = 255;
                if (val < -255) val = -255;

                // Bazowy kolor wody (R=10, G=50, B=100)
                // Dodajemy val do składowych, żeby uzyskać grzbiety i doliny
                
                let r = 10 + val * 0.5;
                let g = 60 + val * 0.8;
                let b = 140 + val;

                // Clamp colors
                r = Math.max(0, Math.min(255, r));
                g = Math.max(0, Math.min(255, g));
                b = Math.max(0, Math.min(255, b));

                // Składanie piksela (Alpha, Blue, Green, Red)
                data32[i] = (255 << 24) | (b << 16) | (g << 8) | r;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // --- Pętla Główna ---
        let lastTime = performance.now();
        let frames = 0;
        let lastFpsTime = lastTime;

        function loop() {
            if (running) {
                updatePhysics();
            }
            render();

            // FPS Counter
            frames++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                ui.fps.innerText = frames;
                frames = 0;
                lastFpsTime = now;
            }

            requestAnimationFrame(loop);
        }

        // --- Obsługa UI ---

        function setMode(newMode) {
            mode = newMode;
            // Aktualizacja przycisków
            if (mode === 'single') {
                ui.btnSingle.className = "flex-1 py-2 px-3 text-sm rounded bg-blue-100 text-blue-700 border border-blue-200 hover:bg-blue-200 font-medium transition-colors";
                ui.btnDouble.className = "flex-1 py-2 px-3 text-sm rounded bg-slate-100 text-slate-600 border border-slate-200 hover:bg-slate-200 transition-colors";
            } else {
                ui.btnSingle.className = "flex-1 py-2 px-3 text-sm rounded bg-slate-100 text-slate-600 border border-slate-200 hover:bg-slate-200 transition-colors";
                ui.btnDouble.className = "flex-1 py-2 px-3 text-sm rounded bg-blue-100 text-blue-700 border border-blue-200 hover:bg-blue-200 font-medium transition-colors";
            }
            initWalls();
        }

        ui.btnSingle.addEventListener('click', () => setMode('single'));
        ui.btnDouble.addEventListener('click', () => setMode('double'));

        ui.inpSlit.addEventListener('input', (e) => {
            slitSize = parseInt(e.target.value);
            ui.valSlit.innerText = slitSize;
            initWalls();
        });

        ui.inpFreq.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            ui.valFreq.innerText = val;
            frequency = val * 0.03; // Skalowanie dla fizyki
        });

        ui.btnPause.addEventListener('click', () => {
            running = !running;
            if (running) {
                ui.txtPause.innerText = "Pauza";
                ui.btnPause.innerHTML = `<i data-lucide="pause" class="w-4 h-4"></i> Pauza`;
            } else {
                ui.txtPause.innerText = "Wznów";
                ui.btnPause.innerHTML = `<i data-lucide="play" class="w-4 h-4"></i> Wznów`;
            }
            if(typeof lucide !== 'undefined') lucide.createIcons();
        });

        ui.btnReset.addEventListener('click', () => {
            buffer1.fill(0);
            buffer2.fill(0);
            time = 0;
            initWalls();
        });

        // Start
        // Ustawienie początkowej częstotliwości zgodnie z suwakiem
        frequency = parseInt(ui.inpFreq.value) * 0.03; 
        initWalls();
        loop();

    </script>
</body>
</html>